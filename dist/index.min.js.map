{"version":3,"file":null,"sources":["../src/utils.js","../src/schema-parser.js","../src/index.js"],"sourcesContent":["\r\nexport function isIndexableType (value) {\r\n  return value != null && (// Using \"!=\" instead of \"!==\" to check for both null and undefined!\r\n      typeof value === 'string' ||\r\n      typeof value === 'number' ||\r\n      value instanceof Date ||\r\n      (Array.isArray(value) && value.every(isIndexableType))\r\n    )\r\n}\r\n","class SchemaParser {\r\n\r\n  /**\r\n   * Schema parser\r\n   *\r\n   * @param schema\r\n   */\r\n  constructor (schema) {\r\n    this.schema = schema\r\n  }\r\n\r\n  /**\r\n   * Extracts foreign keys from the schema\r\n   *\r\n   * @returns Object\r\n   */\r\n  getForeignKeys () {\r\n    let foreignKeys = {}\r\n\r\n    Object.keys(this.schema).forEach(table => {\r\n      let indexes = this.schema[table].split(',')\r\n\r\n      foreignKeys[table] = indexes\r\n        .filter(idx => idx.indexOf('->') !== -1)\r\n        .map(idx => {\r\n          // split the column and foreign table info\r\n          let [column, target] = idx.split('->').map(x => x.trim())\r\n\r\n          return {\r\n            index: column,\r\n            targetTable: target.split('.')[0],\r\n            targetIndex: target.split('.')[1]\r\n          }\r\n        })\r\n    })\r\n\r\n    return foreignKeys\r\n  }\r\n\r\n  /**\r\n   * Get schema without the foreign key definitions\r\n   *\r\n   * @returns Object\r\n   */\r\n  getCleanedSchema () {\r\n    let schema = {}\r\n\r\n    Object.keys(this.schema).forEach(table => {\r\n      let indexes = this.schema[table].split(',')\r\n\r\n      // Remove foreign keys syntax before calling the original method\r\n      schema[table] = indexes.map(idx => idx.split('->')[0].trim()).join(',')\r\n    })\r\n\r\n    return schema\r\n  }\r\n}\r\n\r\nexport default SchemaParser\r\n","import Dexie from 'dexie'\r\nimport SchemaParser from './schema-parser'\r\nimport {isIndexableType} from './utils'\r\n\r\nconst Relationships = (db) => {\r\n  // Use Dexie.Promise to ensure transaction safety.\r\n  const Promise = Dexie.Promise\r\n\r\n  /**\r\n   * Iterate through all items and collect related records\r\n   *\r\n   * @param relationships\r\n   *\r\n   * @returns {Dexie.Promise}\r\n   */\r\n  db.Table.prototype.with = function (relationships) {\r\n    return this.toCollection().with(relationships)\r\n  }\r\n\r\n  /**\r\n   * Iterate through all items and collect related records\r\n   *\r\n   * @param relationships\r\n   *\r\n   * @returns {Dexie.Promise}\r\n   */\r\n  db.Collection.prototype.with = function (relationships) {\r\n    const baseTable = this._ctx.table.name\r\n    const databaseTables = db._allTables\r\n\r\n    // this holds tables that have foreign keys pointing at the current table\r\n    let usableForeignTables = []\r\n\r\n    // validate target tables and add them into our usable tables object\r\n    Object.keys(relationships).forEach((column) => {\r\n      let tableOrIndex = relationships[column]\r\n      let matchingIndex = this._ctx.table.schema.idxByName[tableOrIndex]\r\n\r\n      if (matchingIndex && matchingIndex.hasOwnProperty('foreignKey')) {\r\n        let index = matchingIndex\r\n        usableForeignTables.push({\r\n          column: column,\r\n          index: index.foreignKey.targetIndex,\r\n          tableName: index.foreignKey.targetTable,\r\n          targetIndex: index.foreignKey.index,\r\n          oneToOne: true\r\n        })\r\n      } else {\r\n        let table = tableOrIndex\r\n\r\n        if (!databaseTables.hasOwnProperty(table)) {\r\n          throw new Error('Relationship table ' + table + ' doesn\\'t exist.')\r\n        }\r\n\r\n        if (!databaseTables[table].schema.hasOwnProperty('foreignKeys')) {\r\n          throw new Error('Relationship table ' + table + ' doesn\\'t have foreign keys set.')\r\n        }\r\n\r\n        // remove the foreign keys that don't link to the base table\r\n        let columns = databaseTables[table].schema.foreignKeys.filter(column => column.targetTable === baseTable)\r\n\r\n        if (columns.length > 0) {\r\n          usableForeignTables.push({\r\n            column: column,\r\n            index: columns[0].index,\r\n            tableName: table,\r\n            targetIndex: columns[0].targetIndex\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n    return this.toArray().then(rows => {\r\n      //\r\n      // Extract the mix of all related keys in all rows\r\n      //\r\n      let queries = usableForeignTables\r\n        .map(foreignTable => {\r\n          // For each foreign table, query all items that any row refers to\r\n          let tableName = foreignTable.tableName\r\n          let allRelatedKeys = rows\r\n            .map(row => row[foreignTable.targetIndex])\r\n            .filter(isIndexableType)\r\n\r\n          // Build the Collection to retrieve all related items\r\n          return databaseTables[tableName]\r\n              .where(foreignTable.index)\r\n              .anyOf(allRelatedKeys)\r\n        })\r\n\r\n      // Execute queries in parallell\r\n      let queryPromises = queries.map(query => query.toArray())\r\n\r\n      //\r\n      // Await all results and then try mapping each response\r\n      // with its corresponding row and attach related items onto each row\r\n      //\r\n      return Promise.all(queryPromises).then(queryResults => {\r\n        usableForeignTables.forEach((foreignTable, idx) => {\r\n          let tableName = foreignTable.tableName\r\n          let result = queryResults[idx]\r\n          let targetIndex = foreignTable.targetIndex\r\n          let foreignIndex = foreignTable.index\r\n          let column = foreignTable.column\r\n\r\n          // Create a lookup by targetIndex (normally 'id')\r\n          // and set the column onto the target\r\n          let lookup = {}\r\n          result.forEach(record => {\r\n            let foreignKey = record[foreignIndex]\r\n            if (foreignTable.oneToOne) {\r\n              lookup[foreignKey] = record\r\n            } else {\r\n              (lookup[foreignKey] = lookup[foreignKey] || [])\r\n                .push(record)\r\n            }\r\n          })\r\n\r\n          // Populate column on each row\r\n          rows.forEach(row => {\r\n            let foreignKey = row[targetIndex]\r\n            let record = lookup[foreignKey]\r\n            if (!record) {\r\n              throw new Error(\r\n                `Could not lookup foreign key where ` +\r\n                `${tableName}.${foreignIndex} == ${baseTable}.${column}. ` +\r\n                `The content of the failing key was: ${JSON.stringify(foreignKey)}.`)\r\n            }\r\n\r\n            // Set it as a non-enumerable property so that the object can be safely put back\r\n            // to indexeddb without storing relations redundantly (IndexedDB will only store \"own non-\r\n            // enumerable properties\")\r\n            Object.defineProperty(row, column, {\r\n              value: record,\r\n              enumerable: false,\r\n              configurable: true,\r\n              writable: true\r\n            })\r\n          })\r\n        })\r\n      }).then(() => rows)\r\n    })\r\n  }\r\n\r\n  db.Version.prototype._parseStoresSpec = Dexie.override(\r\n    db.Version.prototype._parseStoresSpec,\r\n    parseStoresSpec => function (storesSpec, outDbSchema) {\r\n      const parser = new SchemaParser(storesSpec)\r\n\r\n      let foreignKeys = parser.getForeignKeys()\r\n      // call the original method\r\n      let rv = parseStoresSpec.call(this, parser.getCleanedSchema(), outDbSchema)\r\n\r\n      // set foreign keys into database table objects\r\n      // to use later in 'with' method\r\n      Object.keys(outDbSchema).forEach(table => {\r\n        if (foreignKeys.hasOwnProperty(table)) {\r\n          outDbSchema[table].foreignKeys = foreignKeys[table]\r\n          foreignKeys[table].forEach(fk => {\r\n            outDbSchema[table].idxByName[fk.index].foreignKey = fk\r\n          })\r\n        }\r\n      })\r\n\r\n      return rv\r\n    })\r\n}\r\n\r\nexport default Relationships\r\n"],"names":["isIndexableType","value","Date","Array","isArray","every","SchemaParser","schema","this","getForeignKeys","foreignKeys","Object","keys","forEach","table","indexes","split","filter","idx","indexOf","map","x","trim","column","target","index","targetTable","targetIndex","getCleanedSchema","join","db","const","Promise","Dexie","Table","prototype","with","relationships","toCollection","Collection","baseTable","_ctx","name","databaseTables","_allTables","usableForeignTables","let","tableOrIndex","matchingIndex","idxByName","hasOwnProperty","push","foreignKey","tableName","oneToOne","Error","columns","length","toArray","then","rows","queries","foreignTable","allRelatedKeys","row","where","anyOf","queryPromises","query","all","queryResults","result","foreignIndex","lookup","record","JSON","stringify","defineProperty","enumerable","configurable","writable","Version","_parseStoresSpec","override","parseStoresSpec","storesSpec","outDbSchema","parser","rv","call","fk"],"mappings":"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"}